# 工程代码详细解析（STM32F407 · CAN_BOX）


---

## 1. 项目概览与代码结构

- 工程类型：STM32CubeIDE（STM32F407ZG，FreeRTOS，HAL）
- 主外设：
  - CAN1（工作通道，500 kbps）
  - USART2（115200，printf日志输出）
  - SPI1（当前未用于MCP2515，硬件已移除）
  - TIM1（作为HAL时间基，uwTick）
- 主要源文件位置（Core目录）：
  - 入口与系统初始化：Core/Src/main.c
  - 中断入口：Core/Src/stm32f4xx_it.c（声明在 Core/Inc/stm32f4xx_it.h）
  - 外设初始化：
    - CAN：Core/Src/can.c（导出 MX_CAN1_Init 等）
    - USART：Core/Src/usart.c
    - SPI：Core/Src/main.c 中的 MX_SPI1_Init
    - MSP：Core/Src/stm32f4xx_hal_msp.c（GPIO、时钟、NVIC）
  - CAN高层业务模块：
    - 双节点通信：Core/Src/can_dual_node.c（接口在 Core/Inc/can_dual_node.h）
    - 测试盒 API：Core/Src/can_testbox_api.c（接口在 Core/Inc/can_testbox_api.h）
    - PEPS 辅助：Core/Src/can_testbox_peps_helper.c
    - PEPS 过滤器：Core/Src/can_testbox_peps_filter.c
  - 演示/替代模块：
    - 周期发送：Core/Src/can_periodic_send.c
    - 触发发送：Core/Src/can_trigger_send.c
    - 简单Demo：Core/Src/can_simple_demo.c

备注：工程中保留了 CAN2 的初始化与中断入口，但在 main.c 中不再调用 MX_CAN2_Init，CAN2 仅保留以便后续拓展。

---

## 2. 入口与主函数（main.c）

文件：Core/Src/main.c

关键流程：
1) HAL_Init(); SystemClock_Config(); 外设初始化（GPIO、SPI1、USART2、CAN1）。
2) 配置 PEPS 过滤器：CAN_ConfigurePepsFilters();
3) 初始化 CAN 测试盒 API：
   - CAN_TestBox_Init(&hcan1);
   - CAN_TestBox_Enable(true);
   - PEPS_Helper_Init();
4) 启动 FreeRTOS：osKernelInitialize(); 创建任务与队列；osKernelStart();

与日志相关的重定向：
- `_write()` 与 `__io_putchar()` 将 printf 输出重定向到 USART2，工程内使用统一的日志格式，如：
  - 发送日志：[TX] ID:0x123, Data:01 02 03 04 05 06 07 08 [END]
  - 接收日志：[RX] ID:0x456, Data:... [END]

---

## 3. 外设初始化（can.c / usart.c / main.c）

- CAN1（Core/Src/can.c）
  - 500 kbps，Normal 模式，Prescaler=6，BS1=10TQ，BS2=3TQ，SJW=1TQ
  - 导出函数：MX_CAN1_Init()
- CAN2（Core/Src/can.c）
  - 保留定义，Silent 模式；导出 MX_CAN2_Init()（main 未调用）
- USART2（Core/Src/usart.c）
  - 115200/8N1，无流控；HAL_UART_IRQHandler 由 stm32f4xx_it.c 调用
- SPI1（Core/Src/main.c）
  - Master，8-bit，低极性/一边沿，软NSS，预分频32
- 时间基（main.c）
  - HAL_TIM_PeriodElapsedCallback(TIM1) -> HAL_IncTick()

---

## 4. FreeRTOS 使用与任务结构

- 线程创建（main.c）
  - defaultTask：栈 128*4，优先级 Normal
  - CANTestBoxTask：栈 1024*4，优先级 Normal
- 队列创建（main.c）
  - myQueue01：长度 10，元素大小 13 字节（演示用途）

任务函数：
- StartDefaultTask(void*):
  - 目前仅做占位，每 10 秒 osDelay(10000)，留作状态打印/监控扩展
- StartCANTestBoxTask(void*):
  - 启动延时 osDelay(100)
  - CAN_TestBox_SetRxCallback(NULL) 使用默认接收处理
  - 再次调用 PEPS_Helper_Init()
  - 循环内每 1ms 调用 CAN_TestBox_Task(); osDelay(1)

说明：
- 测试盒 API 自身内部维护发送/接收队列与周期报文数组，并在 CAN_TestBox_Task() 中驱动。
- 若导入演示模块（如 can_periodic_send/can_simple_demo），需在 main 中创建对应任务并初始化（详见第 7 节接口用法示例）。

---

## 5. CAN 通讯架构与中断回调调用链

总体路径：
- NVIC -> stm32f4xx_it.c -> HAL_CAN_IRQHandler(&hcan1) -> HAL 回调 -> can_dual_node.c 中的回调 -> 调用 CAN_TestBox API 进行队列/回调处理

关键文件与函数：
- stm32f4xx_it.c：
  - CAN1_TX_IRQHandler / CAN1_RX0_IRQHandler / CAN1_SCE_IRQHandler 均调用 HAL_CAN_IRQHandler(&hcan1)
- can_dual_node.c：
  - HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef* hcan)
    - HAL_CAN_GetRxMessage(..., &RxHeader, RxData)
    - 打印接收日志 [RX] ... [END]
    - CAN_ProcessReceivedMessage(&RxHeader, RxData) 进行双节点业务处理
    - CAN_TestBox_ProcessRxMessage(hcan, &RxHeader, RxData) 将报文交由测试盒 API 处理（入队/回调）
  - HAL_CAN_ErrorCallback(CAN_HandleTypeDef* hcan)
    - 统计错误并调用 CAN_TestBox_ProcessError(hcan)

过滤器：
- PEPS 过滤器（can_testbox_peps_filter.c）对 CAN1 配置 3 个 16bit IDLIST 过滤器，聚焦 SCW1/SCW2/诊断与 PEPS 自定义报文。建议在 CAN 启动前配置。

---

## 6. CAN 测试盒 API（Core/Inc/can_testbox_api.h, Core/Src/can_testbox_api.c）

初始化/控制：
- CAN_TestBox_Init(CAN_HandleTypeDef* hcan)
  - 创建发送/接收队列
  - 启动 CAN 并激活 RX、ERROR 中断
  - 内部状态 g_initialized/g_running 置位
- CAN_TestBox_DeInit()
- CAN_TestBox_Enable(bool enable)
- CAN_TestBox_IsRunning()

单帧发送：
- CAN_TestBox_SendSingleFrame(const CAN_TestBox_Message_t* msg)
- CAN_TestBox_SendSingleFrameQuick(id, dlc, data, is_extended)

周期发送：
- CAN_TestBox_StartPeriodicMessage(msg, period_ms, &handle_id)
- CAN_TestBox_StopPeriodicMessage(handle_id)
- CAN_TestBox_ModifyPeriodicPeriod(handle_id, new_period_ms)
- CAN_TestBox_ModifyPeriodicData(handle_id, new_data, dlc)
- CAN_TestBox_StopAllPeriodicMessages()

连续帧发送：
- CAN_TestBox_SendBurstFrames(const CAN_TestBox_BurstMsg_t* cfg)
- CAN_TestBox_SendBurstFramesQuick(...)

接收与回调：
- CAN_TestBox_SetRxCallback(CAN_TestBox_RxCallback_t cb)
  - cb 为 NULL 时走默认处理：将接收报文入 g_receive_queue
- CAN_TestBox_ReceiveMessage(CAN_TestBox_Message_t* msg, timeout_ms)
- CAN_TestBox_ClearRxQueue()

统计与状态：
- CAN_TestBox_GetStatistics(CAN_TestBox_Statistics_t* stats)
- CAN_TestBox_ResetStatistics()
- CAN_TestBox_GetBusStatus(), CAN_TestBox_GetLastError()
- CAN_TestBox_SelfTest()

周期驱动：
- CAN_TestBox_Task()
  - 处理 g_periodic_messages 定时发送
  - 刷新统计信息与运行时长

内部发送实现：
- 统一通过 HAL_CAN_AddTxMessage()，并打印 [TX] ... [END] 格式日志（避免乱码，紧凑格式）。

---

## 7. PEPS 辅助与过滤器模块

- 过滤器（can_testbox_peps_filter.c）
  - 函数：CAN_ConfigurePepsFilters()，对 CAN1 配置 ID 列表过滤器，聚焦 SCW1/SCW2 唤醒、诊断与 PEPS 自定义报文。
- 辅助模块（can_testbox_peps_helper.c）
  - PEPS_Helper_Init()
    - 重新启动 USART2 单字节中断接收（HAL_UART_Receive_IT），供上位机或人工通过串口下发控制字节
  - 串口控制字节映射到周期报文：
    - 0xA1/0xC1：开启 SCW1 唤醒（ID=0x05B，周期 200ms），使用 CAN_TestBox_StartPeriodicMessage 返回句柄并保存
    - 0xB1：关闭所有周期报文（封装 StopAll）
    - 0xA2/0xC2：开启 SCW2 唤醒（ID=0x401）
    - 0xA3/0xB3：开启/关闭 钥匙位置（ID=0x442）
    - 0xA4/0xB4：开启/关闭 BSI 状态（ID=0x036/0x301/0x300 等）
  - 弱定义回调：`__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef* huart)` 中处理 g_uart_rx_char 并循环重启单字符接收。

注意：工程中 can_trigger_send.c 也提供了一个弱定义 HAL_UART_RxCpltCallback（用于‘1/2/3’触发不同 ID 发送），若两个模块同时编译，链接器将择一使用弱符号；建议仅启用一个串口驱动模块或提供统一的强定义回调以避免冲突。

---

## 8. 双节点通信模块（can_dual_node.c/h）

功能概要：
- 统一封装发送：CAN_SendToWCMCU(id, data, len)，打印紧凑 [TX] 日志并维护统计
- 业务消息：心跳、数据请求/响应、状态、控制、错误、ACK 等（ID 常量在 can_dual_node.h）
- 统计/状态：CAN_ResetStats/CAN_GetStats/CAN_PrintStats/CAN_GetSuccessRate 等
- 过滤器：静态 CAN_ConfigFilter()（本模块自配的过滤器逻辑），工程当前更推荐使用 PEPS 过滤器模块统一配置

中断回调：
- HAL_CAN_RxFifo0MsgPendingCallback(CAN1)
  - 读取 FIFO0 -> 打印 [RX] -> CAN_ProcessReceivedMessage -> CAN_TestBox_ProcessRxMessage
- HAL_CAN_TxMailboxXCompleteCallback(CAN1)
  - 发送完成占位（可扩展）
- HAL_CAN_ErrorCallback(CAN1)
  - 统计错误并调用 CAN_TestBox_ProcessError

当前工程定位：保留双节点业务处理能力，但主流程以“测试盒 API + PEPS 过滤/辅助”为核心；如需纯演示/测试，可启用第 9 节的演示模块。

---

## 9. 演示/替代模块与集成示例

工程包含三种发送演示模块，便于快速验证 CAN 通信：

1) 周期发送（can_periodic_send.c）
- 接口：
  - CAN_PeriodicSend_Init()
  - CAN_PeriodicSend_Task(void*)
  - CAN_PeriodicSend_GetStats / ResetStats
- 行为：每 2 秒发送一帧（ID=0x123），数据包含计数与时间戳
- 集成方式（示例代码片段）：

```c
// main.c 中，在创建任务处：
extern HAL_StatusTypeDef CAN_PeriodicSend_Init(void);
extern void CAN_PeriodicSend_Task(void*);

// 初始化后（MX_CAN1_Init 之后），可调用：
CAN_PeriodicSend_Init();

// 创建任务：
const osThreadAttr_t periodicTaskAttr = {
  .name = "CANPeriodicTask",
  .stack_size = 512 * 4,
  .priority = (osPriority_t)osPriorityNormal,
};
osThreadNew(CAN_PeriodicSend_Task, NULL, &periodicTaskAttr);
```

2) 触发发送（can_trigger_send.c）
- 接口：
  - CAN_TriggerSend_Init()
  - CAN_TriggerSend_Task(void*)
  - CAN_TriggerSend_SendMessage1/2/3()（ID=0x100/0x200/0x300）
- 行为：串口接收字符 ‘1/2/3’ 触发不同 ID 的 CAN 发送
- 注意：与 PEPS 辅助模块存在弱回调重名，选择其一使用

3) 最简单 Demo（can_simple_demo.c）
- 接口：
  - CAN_SimpleDemo_Init()
  - CAN_SimpleDemo_Task(void*)
  - CAN_SimpleDemo_GetStats()
- 行为：1/2/3/5/10 秒周期发送不同类型报文（ID=0x100/0x200/0x300/0x400/0x500）
- 集成方式同“周期发送”，初始化后创建任务即可

---

## 10. 常用接口使用方式速览（代码示例）

- 发送单帧：
```c
CAN_TestBox_Message_t msg = {
  .id = 0x123,
  .dlc = 8,
  .data = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08},
  .is_extended = false,
  .is_remote = false,
};
CAN_TestBox_SendSingleFrame(&msg);
// 或快速接口：
uint8_t d[8] = {0};
CAN_TestBox_SendSingleFrameQuick(0x456, 8, d, false);
```

- 启动周期报文并修改：
```c
uint8_t handle = 0;
CAN_TestBox_Message_t hb = {
  .id = 0x100,
  .dlc = 4,
  .data = {0xAA,0x55,0x00,0x01},
  .is_extended = false,
  .is_remote = false,
};
CAN_TestBox_StartPeriodicMessage(&hb, 1000, &handle);
// 修改周期：
CAN_TestBox_ModifyPeriodicPeriod(handle, 500);
// 修改数据：
uint8_t new_data[4] = {0xAA,0x55,0x00,0x02};
CAN_TestBox_ModifyPeriodicData(handle, new_data, 4);
// 停止：
CAN_TestBox_StopPeriodicMessage(handle);
```

- 设置接收回调：
```c
static void MyRx(const CAN_TestBox_Message_t* m) {
  // 用户处理接收报文
}
CAN_TestBox_SetRxCallback(MyRx);
```

- 读取接收队列：
```c
CAN_TestBox_Message_t rcv;
if (CAN_TestBox_ReceiveMessage(&rcv, 10) == CAN_TESTBOX_OK) {
  // 处理 rcv
}
```

---

## 11. 中断服务、回调与日志

- 中断入口：stm32f4xx_it.c -> HAL_CAN_IRQHandler(&hcan1)
- HAL 回调落点：can_dual_node.c
  - Rx：HAL_CAN_RxFifo0MsgPendingCallback -> 打印 [RX] -> 业务处理 -> 测试盒 API 入队/回调
  - Err：HAL_CAN_ErrorCallback -> 统计错误 -> 测试盒 API 错误处理
- 串口回调（弱定义）：
  - can_testbox_peps_helper.c 与 can_trigger_send.c 均提供弱定义 HAL_UART_RxCpltCallback
  - 建议提供统一强定义，集中处理串口协议并分发到对应模块
- 日志：统一使用 printf，经 `_write`/`__io_putchar` 重定向到 USART2（115200）

---

## 12. 工程运行路径总结

1) 上电后，main.c 完成系统时钟与外设初始化；
2) 配置 PEPS 过滤器，限制接收内容；
3) 初始化 CAN 测试盒 API，开启队列与中断；
4) 启动 FreeRTOS，进入两条任务：
   - defaultTask：空循环，占位
   - CANTestBoxTask：每 1ms 调用 CAN_TestBox_Task 驱动周期发送与队列处理
5) CAN 接收中断进入 can_dual_node.c 的 Rx 回调，随后转给测试盒 API 做进一步处理（或用户自定义回调）。

---

## 13. 二次开发建议

- 若仅做演示：可在 main.c 增加演示任务（周期发送/简单Demo），不使用 PEPS 辅助串口回调以免冲突。
- 若做业务测试：建议保留“测试盒 API + PEPS 过滤”，串口通过 PEPS 辅助进行控制；必要时提供统一强定义 HAL_UART_RxCpltCallback。
- 若禁用 CAN2：除不调用 MX_CAN2_Init 外，可在 stm32f4xx_hal_msp.c 关闭 CAN2 时钟与 NVIC 配置，清理 stm32f4xx_it.c 的 CAN2 中断入口。
- 过滤器：CubeMX 重生成后，建议将过滤器配置统一收敛到一个模块，保证顺序与 bank 不冲突（SlaveStartFilterBank=14）。
- 打印：当前日志采用紧凑格式，避免中文乱码；如需更详细日志，建议统一在英文或 UTF-8 无 BOM 环境下输出。

---

## 14. 关键文件速查表

- Core/Src/main.c：入口、任务创建、SPI1/printf 重定向
- Core/Src/can.c：CAN1/2 初始化参数（CAN2 未启用）
- Core/Src/stm32f4xx_it.c：CAN/USART/TIM 中断入口
- Core/Src/can_dual_node.c：CAN 业务与 HAL 回调、统计
- Core/Inc/can_dual_node.h：CAN 业务接口与常量
- Core/Src/can_testbox_api.c / Core/Inc/can_testbox_api.h：测试盒统一 API
- Core/Src/can_testbox_peps_filter.c：PEPS 过滤器组态
- Core/Src/can_testbox_peps_helper.c：PEPS 串口辅助控制
- Core/Src/can_periodic_send.c / can_trigger_send.c / can_simple_demo.c：演示/替代模块

---

如需我将上述演示模块在 main.c 中以最小侵入方式挂载，请告知目标模式（周期/触发/简单Demo），我可按当前工程结构提交相应初始化与任务创建的补丁。