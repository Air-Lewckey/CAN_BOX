# CAN测试盒功能运行链路

## 系统架构图

```
[CAN总线] ←→ [CAN控制器] ←→ [CAN中断处理] ←→ [应用层处理]
                                                      ↓
[串口终端] ←→ [UART控制器] ←→ [串口中断处理] ←→ [指令解析处理]
```

## 1. 系统初始化流程

### 1.1 主函数入口
**文件位置**: `Core/Src/main.c`
**函数**: `main()`

```c
int main(void)
{
  // 系统初始化
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_SPI1_Init();
  MX_USART2_UART_Init();  // 串口初始化
  MX_CAN1_Init();         // CAN1初始化
  MX_CAN2_Init();         // CAN2初始化
  
  // 创建FreeRTOS任务
  osKernelInitialize();
  defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
  CANTestBoxTaskHandle = osThreadNew(StartCANTestBoxTask, NULL, &CANTestBoxTask_attributes);
  
  osKernelStart();
}
```

### 1.2 CAN控制器配置
**文件位置**: `Core/Src/can.c`

#### CAN1配置 (正常模式)
```c
void MX_CAN1_Init(void)
{
  hcan1.Instance = CAN1;
  hcan1.Init.Prescaler = 6;           // 波特率预分频器，实现500Kbps
  hcan1.Init.Mode = CAN_MODE_NORMAL;  // 正常模式，可发送和接收
  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan1.Init.TimeSeg1 = CAN_BS1_10TQ; // 时间段1：10个时间量子
  hcan1.Init.TimeSeg2 = CAN_BS2_3TQ;  // 时间段2：3个时间量子
  // ... 其他配置
}
```

#### CAN2配置 (静默监听模式)
```c
void MX_CAN2_Init(void)
{
  hcan2.Instance = CAN2;
  hcan2.Init.Prescaler = 6;
  hcan2.Init.Mode = CAN_MODE_SILENT;  // 静默监听模式，只接收不发送
  // ... 其他配置相同
}
```

### 1.3 串口配置
**文件位置**: `Core/Src/usart.c`

```c
void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;      // 波特率115200
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX; // 收发模式
  // ... 其他配置
}
```

## 2. CAN消息接收处理链路

### 2.1 硬件中断触发
**文件位置**: `Core/Src/can_dual_node.c`
**函数**: `HAL_CAN_RxFifo0MsgPendingCallback()`

当CAN控制器接收到消息时，硬件自动触发FIFO0接收中断：

```c
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    CAN_RxHeaderTypeDef rx_header;
    uint8_t rx_data[8];
    
    // 从FIFO0获取消息
    if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &rx_header, rx_data) == HAL_OK)
    {
        // 更新统计信息
        g_can_stats.rx_total_count++;
        
        // 调用测试盒处理函数
        CAN_TestBox_ProcessRxMessage(hcan, &rx_header, rx_data);
        
        // 调用应用层处理函数
        CAN_ProcessReceivedMessage(hcan, &rx_header, rx_data);
    }
}
```

### 2.2 测试盒API处理
**文件位置**: `Core/Src/can_testbox_api.c`
**函数**: `CAN_TestBox_ProcessRxMessage()`

```c
void CAN_TestBox_ProcessRxMessage(CAN_HandleTypeDef *hcan, CAN_RxHeaderTypeDef *rx_header, uint8_t *rx_data)
{
    // 创建消息结构体
    CAN_TestBox_Message_t message;
    message.id = (rx_header->IDE == CAN_ID_EXT) ? rx_header->ExtId : rx_header->StdId;
    message.dlc = rx_header->DLC;
    message.is_extended = (rx_header->IDE == CAN_ID_EXT);
    message.is_remote = (rx_header->RTR == CAN_RTR_REMOTE);
    memcpy(message.data, rx_data, rx_header->DLC);
    
    // 将消息放入接收队列
    if (g_receive_queue != NULL) {
        osMessageQueuePut(g_receive_queue, &message, 0, 0);
    }
    
    // 调用用户回调函数
    if (g_rx_callback != NULL) {
        g_rx_callback(&message);
    }
}
```

### 2.3 应用层消息处理
**文件位置**: `Core/Src/can_dual_node.c`
**函数**: `CAN_ProcessReceivedMessage()`

```c
void CAN_ProcessReceivedMessage(CAN_HandleTypeDef *hcan, CAN_RxHeaderTypeDef *rx_header, uint8_t *rx_data)
{
    uint32_t msg_id = (rx_header->IDE == CAN_ID_EXT) ? rx_header->ExtId : rx_header->StdId;
    
    // 根据消息ID进行分类处理
    switch (msg_id) {
        case 0x123:
            CAN_ProcessStatusMessage(rx_header, rx_data);
            break;
        case 0x456:
            CAN_ProcessErrorMessage(rx_header, rx_data);
            break;
        // ... 其他消息类型
    }
    
    // 打印接收到的消息到串口
    CAN_PrintReceivedMessage(rx_header, rx_data);
}
```

### 2.4 串口打印输出
**文件位置**: `Core/Src/can_dual_node.c`
**函数**: `CAN_PrintReceivedMessage()`

```c
void CAN_PrintReceivedMessage(CAN_RxHeaderTypeDef *rx_header, uint8_t *rx_data)
{
    uint32_t msg_id = (rx_header->IDE == CAN_ID_EXT) ? rx_header->ExtId : rx_header->StdId;
    
    // 按照指定格式打印接收消息
    printf("[RX] ID:0x%03X, Data:", (unsigned int)msg_id);
    
    if (rx_header->RTR == CAN_RTR_DATA) {
        for (int i = 0; i < rx_header->DLC; i++) {
            printf("%02X", rx_data[i]);
            if (i < rx_header->DLC - 1) printf(" ");
        }
    } else {
        printf("RTR");
    }
    
    printf(" [END]\r\n");
}
```

## 3. 串口配置与printf重定向

### 3.1 printf重定向实现
**文件位置**: `Core/Src/main.c`
**函数**: `_write()`

系统通过重定义`_write`函数将printf输出重定向到USART2：

```c
int _write(int file, char *ptr, int len)
{
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}
```

### 3.2 串口硬件配置
- **串口**: USART2
- **波特率**: 115200
- **数据位**: 8位
- **停止位**: 1位
- **校验位**: 无
- **流控**: 无

## 4. 串口指令接收与解析链路

### 4.1 串口接收中断初始化
**文件位置**: `Core/Src/can_testbox_peps_helper.c`
**函数**: `PEPS_Helper_Init()`

```c
HAL_StatusTypeDef PEPS_Helper_Init(void)
{
    // 启动单字符接收中断
    HAL_StatusTypeDef status = HAL_UART_Receive_IT(&huart2, &g_uart_rx_char, 1);
    
    if (status == HAL_OK) {
        printf("PEPS Helper initialized successfully\r\n");
    }
    
    return status;
}
```

### 4.2 串口接收中断回调
**文件位置**: `Core/Src/can_testbox_peps_helper.c`
**函数**: `HAL_UART_RxCpltCallback()`

```c
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART2)
    {
        // 处理接收到的字符
        PEPS_Helper_ProcessChar(g_uart_rx_char);
        
        // 重新启动单字符接收
        HAL_UART_Receive_IT(&huart2, &g_uart_rx_char, 1);
    }
}
```

### 4.3 指令解析处理
**文件位置**: `Core/Src/can_testbox_peps_helper.c`
**函数**: `PEPS_Helper_ProcessChar()`

```c
static void PEPS_Helper_ProcessChar(uint8_t received_char)
{
    uint8_t data[8];
    
    switch (received_char) {
        case '1':  // PEPS唤醒帧 (0x104)
            data[0] = 0x01; data[1] = 0x02; data[2] = 0x03; data[3] = 0x04;
            data[4] = 0x05; data[5] = 0x06; data[6] = 0x07; data[7] = 0x08;
            PEPS_Helper_StartPeriodicMessage(PEPS_WAKEUP_INDEX, 0x104, data, PEPS_WAKEUP_PERIOD);
            break;
            
        case '2':  // PEPS状态监控 (0x301)
            data[0] = 0x11; data[1] = 0x22; data[2] = 0x33; data[3] = 0x44;
            data[4] = 0x55; data[5] = 0x66; data[6] = 0x77; data[7] = 0x88;
            PEPS_Helper_StartPeriodicMessage(PEPS_STATUS_INDEX, 0x301, data, PEPS_STATUS_PERIOD);
            break;
            
        case 0xFF:  // 停止所有周期报文
            PEPS_Helper_StopAllPeriodicMessagesEx();
            break;
            
        case 0x00:  // 系统复位
            NVIC_SystemReset();
            break;
            
        default:
            // 忽略其他字符
            break;
    }
}
```

## 5. CAN消息发送链路

### 5.1 周期性消息启动
**文件位置**: `Core/Src/can_testbox_peps_helper.c`
**函数**: `PEPS_Helper_StartPeriodicMessage()`

```c
static void PEPS_Helper_StartPeriodicMessage(uint8_t index, uint32_t id, uint8_t *data, uint32_t period)
{
    // 先停止之前的周期性消息
    PEPS_Helper_StopPeriodicMessage(index);
    
    // 创建新的CAN消息
    CAN_TestBox_Message_t message;
    message.id = id;
    message.dlc = 8;
    message.is_extended = false;
    message.is_remote = false;
    memcpy(message.data, data, 8);
    
    // 启动周期性消息
    CAN_TestBox_Status_t status = CAN_TestBox_StartPeriodicMessage(&message, period, &g_peps_periodic_handles[index]);
}
```

### 5.2 测试盒API发送处理
**文件位置**: `Core/Src/can_testbox_api.c`
**函数**: `CAN_TestBox_StartPeriodicMessage()`

```c
CAN_TestBox_Status_t CAN_TestBox_StartPeriodicMessage(const CAN_TestBox_Message_t *message, uint32_t period_ms, uint8_t *handle_id)
{
    // 参数验证
    if (message == NULL || handle_id == NULL || period_ms == 0) {
        return CAN_TESTBOX_INVALID_PARAM;
    }
    
    // 查找空闲槽位
    uint8_t index = 0;
    for (index = 0; index < CAN_TESTBOX_MAX_PERIODIC_MSGS; index++) {
        if (!g_periodic_messages[index].enabled) {
            break;
        }
    }
    
    // 配置周期性消息
    g_periodic_messages[index].message = *message;
    g_periodic_messages[index].period_ms = period_ms;
    g_periodic_messages[index].enabled = true;
    g_periodic_messages[index].send_count = 0;
    g_periodic_messages[index].last_send_time = CAN_TestBox_GetTick();
    g_periodic_messages[index].handle_id = index;
    
    *handle_id = index;
    g_periodic_msg_count++;
    
    return CAN_TESTBOX_OK;
}
```

### 5.3 周期性消息处理任务
**文件位置**: `Core/Src/can_testbox_api.c`
**函数**: `CAN_TestBox_ProcessPeriodicMessages()`

```c
static void CAN_TestBox_ProcessPeriodicMessages(void)
{
    uint32_t current_time = CAN_TestBox_GetTick();
    
    for (uint8_t i = 0; i < CAN_TESTBOX_MAX_PERIODIC_MSGS; i++) {
        if (g_periodic_messages[i].enabled) {
            // 检查是否到达发送时间
            if ((current_time - g_periodic_messages[i].last_send_time) >= g_periodic_messages[i].period_ms) {
                // 发送消息
                CAN_TestBox_SendMessage_Internal(&g_periodic_messages[i].message);
                
                // 更新发送时间和计数
                g_periodic_messages[i].last_send_time = current_time;
                g_periodic_messages[i].send_count++;
            }
        }
    }
}
```

### 5.4 底层CAN发送实现
**文件位置**: `Core/Src/can_testbox_api.c`
**函数**: `CAN_TestBox_SendMessage_Internal()`

```c
static CAN_TestBox_Status_t CAN_TestBox_SendMessage_Internal(const CAN_TestBox_Message_t *message)
{
    CAN_TxHeaderTypeDef tx_header;
    uint32_t tx_mailbox;
    
    // 配置发送头
    if (message->is_extended) {
        tx_header.IDE = CAN_ID_EXT;
        tx_header.ExtId = message->id;
    } else {
        tx_header.IDE = CAN_ID_STD;
        tx_header.StdId = message->id;
    }
    
    tx_header.RTR = message->is_remote ? CAN_RTR_REMOTE : CAN_RTR_DATA;
    tx_header.DLC = message->dlc;
    tx_header.TransmitGlobalTime = DISABLE;
    
    // 调用HAL库发送消息
    HAL_StatusTypeDef hal_status = HAL_CAN_AddTxMessage(g_hcan, &tx_header, (uint8_t*)message->data, &tx_mailbox);
    
    if (hal_status == HAL_OK) {
        // 更新统计信息
        g_statistics.tx_total_count++;
        g_statistics.tx_success_count++;
        
        // 打印发送日志
        printf("[TX] ID:0x%03X, Data:", (unsigned int)message->id);
        
        if (!message->is_remote) {
            for (int i = 0; i < message->dlc; i++) {
                printf("%02X", message->data[i]);
                if (i < message->dlc - 1) printf(" ");
            }
        } else {
            printf("RTR");
        }
        
        printf(" [END]\r\n");
        
        return CAN_TESTBOX_OK;
    } else {
        // 发送失败处理
        g_statistics.tx_total_count++;
        g_statistics.tx_error_count++;
        g_statistics.last_error_code = hal_status;
        
        printf("[CAN-ERROR] Failed to send message - ID:0x%03X, Error:%d\r\n", 
               (unsigned int)message->id, hal_status);
        
        return CAN_TESTBOX_ERROR;
    }
}
```

## 6. 任务调度与主循环

### 6.1 CAN测试盒主任务
**文件位置**: `Core/Src/main.c`
**函数**: `StartCANTestBoxTask()`

```c
void StartCANTestBoxTask(void *argument)
{
    // 初始化CAN测试盒
    CAN_TestBox_Init(&hcan1);
    
    // 设置接收回调
    CAN_TestBox_SetRxCallback(NULL);
    
    // 初始化PEPS辅助模块
    PEPS_Helper_Init();
    
    // 主循环
    for(;;)
    {
        // 调用测试盒任务处理函数
        CAN_TestBox_Task();
        
        // 任务延时
        osDelay(1);
    }
}
```

### 6.2 测试盒任务处理
**文件位置**: `Core/Src/can_testbox_api.c`
**函数**: `CAN_TestBox_Task()`

```c
void CAN_TestBox_Task(void)
{
    if (!g_initialized || !g_running) {
        return;
    }
    
    // 处理周期性消息发送
    CAN_TestBox_ProcessPeriodicMessages();
    
    // 更新统计信息
    CAN_TestBox_UpdateStatistics();
}
```

## 7. 完整数据流向图

```
串口指令输入 → UART中断 → 指令解析 → 启动周期消息
     ↓              ↓           ↓           ↓
  终端输入    HAL_UART_RxCpltCallback  ProcessChar  StartPeriodicMessage
     ↓              ↓           ↓           ↓
   字符'1'    处理单个字符    解析为PEPS唤醒   配置周期发送
     ↓              ↓           ↓           ↓
   115200      重启接收中断   创建消息结构    添加到发送队列
     ↓              ↓           ↓           ↓
  USART2      等待下个字符    设置发送参数    定时器触发发送
     ↓              ↓           ↓           ↓
  printf重定向  ←  消息发送  ←  CAN发送API  ←  HAL_CAN_AddTxMessage
     ↓              ↓           ↓           ↓
  串口输出日志    发送完成回调   更新统计信息    CAN总线输出
```

## 8. 关键文件和函数总结

### 8.1 系统初始化
- **文件**: `Core/Src/main.c`
- **关键函数**: `main()`, `StartCANTestBoxTask()`

### 8.2 CAN配置
- **文件**: `Core/Src/can.c`
- **关键函数**: `MX_CAN1_Init()`, `MX_CAN2_Init()`

### 8.3 串口配置
- **文件**: `Core/Src/usart.c`
- **关键函数**: `MX_USART2_UART_Init()`

### 8.4 CAN消息接收
- **文件**: `Core/Src/can_dual_node.c`
- **关键函数**: `HAL_CAN_RxFifo0MsgPendingCallback()`, `CAN_ProcessReceivedMessage()`

### 8.5 串口指令处理
- **文件**: `Core/Src/can_testbox_peps_helper.c`
- **关键函数**: `HAL_UART_RxCpltCallback()`, `PEPS_Helper_ProcessChar()`

### 8.6 CAN消息发送
- **文件**: `Core/Src/can_testbox_api.c`
- **关键函数**: `CAN_TestBox_SendMessage_Internal()`, `CAN_TestBox_ProcessPeriodicMessages()`

### 8.7 printf重定向
- **文件**: `Core/Src/main.c`
- **关键函数**: `_write()`

## 9. 调试和监控

系统提供了完整的调试信息输出：

1. **接收消息格式**: `[RX] ID:0x123, Data:01 02 03 04 [END]`
2. **发送消息格式**: `[TX] ID:0x104, Data:01 02 03 04 05 06 07 08 [END]`
3. **错误信息格式**: `[CAN-ERROR] Failed to send message - ID:0x123, Error:1`

通过串口终端可以实时监控系统运行状态和消息收发情况。